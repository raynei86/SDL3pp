<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: SDL::MutexBase&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSDL.html">SDL</a></li><li class="navelem"><a class="el" href="structSDL_1_1MutexBase.html">MutexBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structSDL_1_1MutexBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SDL::MutexBase&lt; T &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesThreads.html">Threads</a> &raquo; <a class="el" href="group__CategoryMutex.html">Thread Synchronization Primitives</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A means to serialize access to a resource between threads.  
 <a href="structSDL_1_1MutexBase.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for SDL::MutexBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1MutexBase__inherit__graph.png" border="0" usemap="#aSDL_1_1MutexBase_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSDL_1_1MutexBase_3_01T_01_4_inherit__map" id="aSDL_1_1MutexBase_3_01T_01_4_inherit__map">
<area shape="rect" title="A means to serialize access to a resource between threads." alt="" coords="5,79,172,104"/>
<area shape="rect" title=" " alt="" coords="69,5,108,31"/>
<area shape="poly" title=" " alt="" coords="91,44,91,79,86,79,86,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SDL::MutexBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structSDL_1_1MutexBase__coll__graph.png" border="0" usemap="#aSDL_1_1MutexBase_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSDL_1_1MutexBase_3_01T_01_4_coll__map" id="aSDL_1_1MutexBase_3_01T_01_4_coll__map">
<area shape="rect" title="A means to serialize access to a resource between threads." alt="" coords="5,79,172,104"/>
<area shape="rect" title=" " alt="" coords="69,5,108,31"/>
<area shape="poly" title=" " alt="" coords="91,44,91,79,86,79,86,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a463b07bbd81a0cfb1a8d1363a8f090" id="r_a6a463b07bbd81a0cfb1a8d1363a8f090"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1MutexBase.html#a6a463b07bbd81a0cfb1a8d1363a8f090">MutexBase</a> ()</td></tr>
<tr class="memdesc:a6a463b07bbd81a0cfb1a8d1363a8f090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new mutex.  <br /></td></tr>
<tr class="separator:a6a463b07bbd81a0cfb1a8d1363a8f090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5930cdb4c0f50526e8f060d6da3080" id="r_a4d5930cdb4c0f50526e8f060d6da3080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1MutexBase.html#a4d5930cdb4c0f50526e8f060d6da3080">Lock</a> ()</td></tr>
<tr class="memdesc:a4d5930cdb4c0f50526e8f060d6da3080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the mutex.  <br /></td></tr>
<tr class="separator:a4d5930cdb4c0f50526e8f060d6da3080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2f97db9087673ffc7d475d4ef3a713" id="r_aae2f97db9087673ffc7d475d4ef3a713"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1MutexBase.html#aae2f97db9087673ffc7d475d4ef3a713">TryLock</a> ()</td></tr>
<tr class="memdesc:aae2f97db9087673ffc7d475d4ef3a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a mutex without blocking.  <br /></td></tr>
<tr class="separator:aae2f97db9087673ffc7d475d4ef3a713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd25b03e4cdf233184a55b265a2bbe5" id="r_afcd25b03e4cdf233184a55b265a2bbe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1MutexBase.html#afcd25b03e4cdf233184a55b265a2bbe5">Unlock</a> ()</td></tr>
<tr class="memdesc:afcd25b03e4cdf233184a55b265a2bbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex.  <br /></td></tr>
<tr class="separator:afcd25b03e4cdf233184a55b265a2bbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6d3b48d8113448bba1dfef1d0db40e" id="r_a0e6d3b48d8113448bba1dfef1d0db40e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSDL_1_1MutexBase.html#a0e6d3b48d8113448bba1dfef1d0db40e">Destroy</a> ()</td></tr>
<tr class="memdesc:a0e6d3b48d8113448bba1dfef1d0db40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mutex created with <a class="el" href="structSDL_1_1MutexBase.html#a6a463b07bbd81a0cfb1a8d1363a8f090" title="Create a new mutex.">MutexBase.MutexBase()</a>.  <br /></td></tr>
<tr class="separator:a0e6d3b48d8113448bba1dfef1d0db40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;ObjectBox&lt; SDL_Mutex * &gt; T&gt;<br />
struct SDL::MutexBase&lt; T &gt;</div><p>Mutexes (short for "mutual exclusion") are a synchronization primitive that allows exactly one thread to proceed at a time.</p>
<p>Wikipedia has a thorough explanation of the concept:</p>
<p><a href="https://en.wikipedia.org/wiki/Mutex">https://en.wikipedia.org/wiki/Mutex</a></p>
<dl class="section since"><dt>Since</dt><dd>This struct is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a463b07bbd81a0cfb1a8d1363a8f090" name="a6a463b07bbd81a0cfb1a8d1363a8f090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a463b07bbd81a0cfb1a8d1363a8f090">&#9670;&#160;</a></span>MutexBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Mutex * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSDL_1_1MutexBase.html">SDL::MutexBase</a>&lt; T &gt;::MutexBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All newly-created mutexes begin in the <em>unlocked</em> state.</p>
<p>Calls to <a class="el" href="structSDL_1_1MutexBase.html#a4d5930cdb4c0f50526e8f060d6da3080" title="Lock the mutex.">MutexBase.Lock()</a> will not return while the mutex is locked by another thread. See <a class="el" href="structSDL_1_1MutexBase.html#aae2f97db9087673ffc7d475d4ef3a713" title="Try to lock a mutex without blocking.">MutexBase.TryLock()</a> to attempt to lock without blocking.</p>
<p><a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> mutexes are reentrant.</p>
<dl class="section post"><dt>Postcondition</dt><dd>the initialized and unlocked mutex or nullptr on failure; call <a class="el" href="group__CategoryError.html#ga6daa473f21fd59c14bce134abce9bd04" title="Retrieve a message about the last error that occurred on the current thread.">GetError()</a> for more information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1MutexBase.html#a0e6d3b48d8113448bba1dfef1d0db40e" title="Destroy a mutex created with MutexBase.MutexBase().">MutexBase.Destroy</a> </dd>
<dd>
<a class="el" href="structSDL_1_1MutexBase.html#a4d5930cdb4c0f50526e8f060d6da3080" title="Lock the mutex.">MutexBase.Lock</a> </dd>
<dd>
<a class="el" href="structSDL_1_1MutexBase.html#aae2f97db9087673ffc7d475d4ef3a713" title="Try to lock a mutex without blocking.">MutexBase.TryLock</a> </dd>
<dd>
<a class="el" href="structSDL_1_1MutexBase.html#afcd25b03e4cdf233184a55b265a2bbe5" title="Unlock the mutex.">MutexBase.Unlock</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e6d3b48d8113448bba1dfef1d0db40e" name="a0e6d3b48d8113448bba1dfef1d0db40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6d3b48d8113448bba1dfef1d0db40e">&#9670;&#160;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Mutex * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1MutexBase.html">SDL::MutexBase</a>&lt; T &gt;::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be called on any mutex that is no longer needed. Failure to destroy a mutex will result in a system memory or resource leak. While it is safe to destroy a mutex that is <em>unlocked</em>, it is not safe to attempt to destroy a locked mutex, and may result in undefined behavior depending on the platform.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1MutexBase.html#a6a463b07bbd81a0cfb1a8d1363a8f090" title="Create a new mutex.">MutexBase.MutexBase</a> </dd></dl>

</div>
</div>
<a id="a4d5930cdb4c0f50526e8f060d6da3080" name="a4d5930cdb4c0f50526e8f060d6da3080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5930cdb4c0f50526e8f060d6da3080">&#9670;&#160;</a></span>Lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Mutex * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1MutexBase.html">SDL::MutexBase</a>&lt; T &gt;::Lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will block until the mutex is available, which is to say it is in the unlocked state and the OS has chosen the caller as the next thread to lock it. Of all threads waiting to lock the mutex, only one may do so at a time.</p>
<p>It is legal for the owning thread to lock an already-locked mutex. It must unlock it the same number of times before it is actually made available for other threads in the system (this is known as a "recursive mutex").</p>
<p>This function does not fail; if mutex is nullptr, it will return immediately having locked nothing. If the mutex is valid, this function will always block until it can lock the mutex, and return with it locked.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1MutexBase.html#aae2f97db9087673ffc7d475d4ef3a713" title="Try to lock a mutex without blocking.">MutexBase.TryLock</a> </dd>
<dd>
<a class="el" href="structSDL_1_1MutexBase.html#afcd25b03e4cdf233184a55b265a2bbe5" title="Unlock the mutex.">MutexBase.Unlock</a> </dd></dl>

</div>
</div>
<a id="aae2f97db9087673ffc7d475d4ef3a713" name="aae2f97db9087673ffc7d475d4ef3a713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2f97db9087673ffc7d475d4ef3a713">&#9670;&#160;</a></span>TryLock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Mutex * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structSDL_1_1MutexBase.html">SDL::MutexBase</a>&lt; T &gt;::TryLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This works just like <a class="el" href="structSDL_1_1MutexBase.html#a4d5930cdb4c0f50526e8f060d6da3080" title="Lock the mutex.">MutexBase.Lock()</a>, but if the mutex is not available, this function returns false immediately.</p>
<p>This technique is useful if you need exclusive access to a resource but don't want to wait for it, and will return to it to try again later.</p>
<p>This function returns true if passed a nullptr mutex.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the mutex would block.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1MutexBase.html#a4d5930cdb4c0f50526e8f060d6da3080" title="Lock the mutex.">MutexBase.Lock</a> </dd>
<dd>
<a class="el" href="structSDL_1_1MutexBase.html#afcd25b03e4cdf233184a55b265a2bbe5" title="Unlock the mutex.">MutexBase.Unlock</a> </dd></dl>

</div>
</div>
<a id="afcd25b03e4cdf233184a55b265a2bbe5" name="afcd25b03e4cdf233184a55b265a2bbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd25b03e4cdf233184a55b265a2bbe5">&#9670;&#160;</a></span>Unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ObjectBox&lt; SDL_Mutex * &gt; T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structSDL_1_1MutexBase.html">SDL::MutexBase</a>&lt; T &gt;::Unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It is legal for the owning thread to lock an already-locked mutex. It must unlock it the same number of times before it is actually made available for other threads in the system (this is known as a "recursive mutex").</p>
<p>It is illegal to unlock a mutex that has not been locked by the current thread, and doing so results in undefined behavior.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="classSDL_1_1SDL.html" title="Initialize the SDL library.">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSDL_1_1MutexBase.html#a4d5930cdb4c0f50526e8f060d6da3080" title="Lock the mutex.">MutexBase.Lock</a> </dd>
<dd>
<a class="el" href="structSDL_1_1MutexBase.html#aae2f97db9087673ffc7d475d4ef3a713" title="Try to lock a mutex without blocking.">MutexBase.TryLock</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>SDL3pp/<a class="el" href="SDL3pp__mutex_8h_source.html">SDL3pp_mutex.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
