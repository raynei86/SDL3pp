<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDL3pp: Atomic Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDL3pp
   </div>
   <div id="projectbrief">A slim C++ wrapper for SDL3</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Atomic Operations<div class="ingroups"><a class="el" href="group__Categories.html">Categories</a> &raquo; <a class="el" href="group__CategoriesThreads.html">Threads</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Atomic operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AtomicInt.html">SDL::AtomicInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing an atomic integer value.  <a href="classSDL_1_1AtomicInt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AtomicU32.html">SDL::AtomicU32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing an atomic unsigned 32-bit value.  <a href="classSDL_1_1AtomicU32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDL_1_1AtomicPointer.html">SDL::AtomicPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing an atomic pointer.  <a href="classSDL_1_1AtomicPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga36d435d444dc115a5cc11fa7027576ec" id="r_ga36d435d444dc115a5cc11fa7027576ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga36d435d444dc115a5cc11fa7027576ec">SDL_CompilerBarrier</a>()&#160;&#160;&#160;DoCompilerSpecificReadWriteBarrier()</td></tr>
<tr class="memdesc:ga36d435d444dc115a5cc11fa7027576ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a compiler barrier.  <br /></td></tr>
<tr class="separator:ga36d435d444dc115a5cc11fa7027576ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga041cb5705236fe51b35cb3d59c1fbba7" id="r_ga041cb5705236fe51b35cb3d59c1fbba7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga041cb5705236fe51b35cb3d59c1fbba7">SDL_MemoryBarrierRelease</a>()&#160;&#160;&#160;SDL_MemoryBarrierReleaseFunction()</td></tr>
<tr class="memdesc:ga041cb5705236fe51b35cb3d59c1fbba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a memory release barrier (macro version).  <br /></td></tr>
<tr class="separator:ga041cb5705236fe51b35cb3d59c1fbba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa33019d94c637a106218dde56b46a20a" id="r_gaa33019d94c637a106218dde56b46a20a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gaa33019d94c637a106218dde56b46a20a">SDL_MemoryBarrierAcquire</a>()&#160;&#160;&#160;SDL_MemoryBarrierAcquireFunction()</td></tr>
<tr class="memdesc:gaa33019d94c637a106218dde56b46a20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a memory acquire barrier (macro version).  <br /></td></tr>
<tr class="separator:gaa33019d94c637a106218dde56b46a20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa8f8635b3a07f02fe26e5cc052a5f6" id="r_ga6aa8f8635b3a07f02fe26e5cc052a5f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#ga6aa8f8635b3a07f02fe26e5cc052a5f6">SDL_CPUPauseInstruction</a>()&#160;&#160;&#160;  DoACPUPauseInACompilerAndArchitectureSpecificWay</td></tr>
<tr class="memdesc:ga6aa8f8635b3a07f02fe26e5cc052a5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to insert a CPU-specific "pause" instruction into the program.  <br /></td></tr>
<tr class="separator:ga6aa8f8635b3a07f02fe26e5cc052a5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae63499665b3f82267248d33e774ace12" id="r_gae63499665b3f82267248d33e774ace12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gae63499665b3f82267248d33e774ace12">SDL::MemoryBarrierRelease</a> ()</td></tr>
<tr class="memdesc:gae63499665b3f82267248d33e774ace12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a memory release barrier (function version).  <br /></td></tr>
<tr class="separator:gae63499665b3f82267248d33e774ace12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd81ade5d5ee905d0ea12d0c6e061668" id="r_gacd81ade5d5ee905d0ea12d0c6e061668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CategoryAtomic.html#gacd81ade5d5ee905d0ea12d0c6e061668">SDL::MemoryBarrierAcquire</a> ()</td></tr>
<tr class="memdesc:gacd81ade5d5ee905d0ea12d0c6e061668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a memory acquire barrier (function version).  <br /></td></tr>
<tr class="separator:gacd81ade5d5ee905d0ea12d0c6e061668"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>IMPORTANT: If you are not an expert in concurrent lockless programming, you should not be using any functions in this file. You should be protecting your data structures with full mutexes instead.</p>
<p><em><b>Seriously, here be dragons!</b></em></p>
<p>You can find out a little more about lockless programming and the subtle issues that can arise here: <a href="https://learn.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming">https://learn.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming</a></p>
<p>There's also lots of good information here:</p>
<ul>
<li><a href="https://www.1024cores.net/home/lock-free-algorithms">https://www.1024cores.net/home/lock-free-algorithms</a></li>
<li><a href="https://preshing.com/">https://preshing.com/</a></li>
</ul>
<p>These operations may or may not actually be implemented using processor specific atomic operations. When possible they are implemented as true processor specific atomic operations. When that is not possible the are implemented using locks that <em>do</em> use the available atomic operations.</p>
<p>All of the atomic operations that modify memory are full memory barriers. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga36d435d444dc115a5cc11fa7027576ec" name="ga36d435d444dc115a5cc11fa7027576ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d435d444dc115a5cc11fa7027576ec">&#9670;&#160;</a></span>SDL_CompilerBarrier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_CompilerBarrier</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;DoCompilerSpecificReadWriteBarrier()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A compiler barrier prevents the compiler from reordering reads and writes to globally visible variables across the call.</p>
<p>This macro only prevents the compiler from reordering reads and writes, it does not prevent the CPU from reordering reads and writes. However, all of the atomic operations that modify memory are full memory barriers.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this macro is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="ga6aa8f8635b3a07f02fe26e5cc052a5f6" name="ga6aa8f8635b3a07f02fe26e5cc052a5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa8f8635b3a07f02fe26e5cc052a5f6">&#9670;&#160;</a></span>SDL_CPUPauseInstruction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_CPUPauseInstruction</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;  DoACPUPauseInACompilerAndArchitectureSpecificWay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be useful in busy-wait loops, as it serves as a hint to the CPU as to the program's intent; some CPUs can use this to do more efficient processing. On some platforms, this doesn't do anything, so using this macro might just be a harmless no-op.</p>
<p>Note that if you are busy-waiting, there are often more-efficient approaches with other synchronization primitives: mutexes, semaphores, condition variables, etc.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>This macro is safe to use from any thread.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0. </dd></dl>

</div>
</div>
<a id="gaa33019d94c637a106218dde56b46a20a" name="gaa33019d94c637a106218dde56b46a20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa33019d94c637a106218dde56b46a20a">&#9670;&#160;</a></span>SDL_MemoryBarrierAcquire</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MemoryBarrierAcquire</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;SDL_MemoryBarrierAcquireFunction()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please see SDL_MemoryBarrierRelease for the details on what memory barriers are and when to use them.</p>
<p>This is the macro version of this functionality; if possible, <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will use compiler intrinsics or inline assembly, but some platforms might need to call the function version of this, MemoryBarrierAcquire, to do the heavy lifting. Apps that can use the macro should favor it over the function.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this macro is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga041cb5705236fe51b35cb3d59c1fbba7" title="Insert a memory release barrier (macro version).">SDL_MemoryBarrierRelease</a> </dd>
<dd>
MemoryBarrierAcquire </dd></dl>

</div>
</div>
<a id="ga041cb5705236fe51b35cb3d59c1fbba7" name="ga041cb5705236fe51b35cb3d59c1fbba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga041cb5705236fe51b35cb3d59c1fbba7">&#9670;&#160;</a></span>SDL_MemoryBarrierRelease</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MemoryBarrierRelease</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;SDL_MemoryBarrierReleaseFunction()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory barriers are designed to prevent reads and writes from being reordered by the compiler and being seen out of order on multi-core CPUs.</p>
<p>A typical pattern would be for thread A to write some data and a flag, and for thread B to read the flag and get the data. In this case you would insert a release barrier between writing the data and the flag, guaranteeing that the data write completes no later than the flag is written, and you would insert an acquire barrier between reading the flag and reading the data, to ensure that all the reads associated with the flag have completed.</p>
<p>In this pattern you should always see a release barrier paired with an acquire barrier and you should gate the data reads/writes with a single flag variable.</p>
<p>For more information on these semantics, take a look at the blog post: <a href="http://preshing.com/20120913/acquire-and-release-semantics">http://preshing.com/20120913/acquire-and-release-semantics</a></p>
<p>This is the macro version of this functionality; if possible, <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> will use compiler intrinsics or inline assembly, but some platforms might need to call the function version of this, MemoryBarrierRelease to do the heavy lifting. Apps that can use the macro should favor it over the function.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this macro is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This macro is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gaa33019d94c637a106218dde56b46a20a" title="Insert a memory acquire barrier (macro version).">SDL_MemoryBarrierAcquire</a> </dd>
<dd>
MemoryBarrierRelease </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacd81ade5d5ee905d0ea12d0c6e061668" name="gacd81ade5d5ee905d0ea12d0c6e061668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd81ade5d5ee905d0ea12d0c6e061668">&#9670;&#160;</a></span>MemoryBarrierAcquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::MemoryBarrierAcquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Please refer to SDL_MemoryBarrierRelease for details. This is a function version, which might be useful if you need to use this functionality from a scripting language, etc. Also, some of the macro versions call this function behind the scenes, where more heavy lifting can happen inside of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>. Generally, though, an app written in C/C++/etc should use the macro version, as it will be more efficient.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this function is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#gaa33019d94c637a106218dde56b46a20a" title="Insert a memory acquire barrier (macro version).">SDL_MemoryBarrierAcquire</a> </dd></dl>

</div>
</div>
<a id="gae63499665b3f82267248d33e774ace12" name="gae63499665b3f82267248d33e774ace12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae63499665b3f82267248d33e774ace12">&#9670;&#160;</a></span>MemoryBarrierRelease()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SDL::MemoryBarrierRelease </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Please refer to SDL_MemoryBarrierRelease for details. This is a function version, which might be useful if you need to use this functionality from a scripting language, etc. Also, some of the macro versions call this function behind the scenes, where more heavy lifting can happen inside of <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a>. Generally, though, an app written in C/C++/etc should use the macro version, as it will be more efficient.</p>
<dl class="section user"><dt>Thread safety:</dt><dd>Obviously this function is safe to use from any thread at any time, but if you find yourself needing this, you are probably dealing with some very sensitive code; be careful!</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since <a class="el" href="namespaceSDL.html" title="the main namespace where all SDL3pp public functions and types live">SDL</a> 3.2.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CategoryAtomic.html#ga041cb5705236fe51b35cb3d59c1fbba7" title="Insert a memory release barrier (macro version).">SDL_MemoryBarrierRelease</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
